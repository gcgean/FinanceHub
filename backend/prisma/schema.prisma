generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  OPERATOR
  CLIENT
}

enum TransactionType {
  REVENUE
  EXPENSE
}

enum TransactionStatus {
  NEW
  SUGGESTED
  PENDING
  APPROVED
  REVIEWED
  LOCKED
}

enum PendencyType {
  CATEGORIZATION
  ATTACHMENT
  COST_CENTER
  APPROVAL
  REVIEW
}

enum PendencyPriority {
  HIGH
  MEDIUM
  LOW
}

enum PendencyStatus {
  PENDING
  IN_PROGRESS
  RESOLVED
  OVERDUE
}

enum ImportSource {
  EXCEL
  RECEIPT
  API
}

enum ImportStatus {
  QUEUED
  PROCESSING
  DONE
  FAILED
}

enum LedgerOperation {
  DEBITO
  CREDITO
}

enum ChartPlanType {
  SINTETICA
  ANALITICA
}

enum RevenueExpense {
  RECEITA
  DESPESA
}

enum DebitCredit {
  DEBITO
  CREDITO
}

enum FixedVariable {
  FIXO
  VARIAVEL
}

enum CostExpense {
  CUSTO
  DESPESA
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  CONFIRM
}

model Company {
  id        String        @id @default(cuid())
  name      String
  cnpj      String?       @unique
  createdAt DateTime      @default(now())
  users     User[]
  txs       Transaction[]
  pendings  Pendency[]
  imports   ImportJob[]

  accounts       Account[]
  costCenters    CostCenter[]
  chartAccounts  ChartAccount[]
  ledgerEntries  BankLedgerEntry[]
  audit          AuditLog[]
}

model User {
  id           String    @id @default(cuid())
  email        String    @unique
  name         String
  passwordHash String
  role         UserRole  @default(OPERATOR)
  companyId    String?
  company      Company?  @relation(fields: [companyId], references: [id])
  createdAt    DateTime  @default(now())

  updatedLedgerEntries BankLedgerEntry[] @relation("LedgerUpdatedBy")
  audit                AuditLog[]
}

model Transaction {
  id                 String            @id @default(cuid())
  companyId           String
  company             Company           @relation(fields: [companyId], references: [id])
  date                DateTime
  description         String
  value               Float
  type                TransactionType
  category            String
  categoryConfidence  Int?
  account             String
  status              TransactionStatus
  costCenter          String?
  attachmentUrl       String?
  notes               String?
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  pendencies          Pendency[]

  @@index([companyId, date])
}

model AccountType {
  id          String   @id @default(cuid())
  code        String   @unique
  description String
  createdAt   DateTime @default(now())
  accounts    Account[]
}

model Account {
  id               String        @id @default(cuid())
  companyId         String
  company           Company       @relation(fields: [companyId], references: [id])
  code             String
  description      String
  active           Boolean       @default(true)
  useInCashFlow    Boolean       @default(true)
  superOnly        Boolean       @default(false)
  defaultConfirmed Boolean       @default(false)
  accountTypeId    String?
  accountType      AccountType?  @relation(fields: [accountTypeId], references: [id])
  createdAt        DateTime      @default(now())

  ledgerEntries BankLedgerEntry[]

  @@unique([companyId, code])
  @@index([companyId])
}

model CostCenter {
  id          String   @id @default(cuid())
  companyId    String
  company      Company  @relation(fields: [companyId], references: [id])
  code        String
  description String
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())

  ledgerSplits BankLedgerEntrySplit[]

  @@unique([companyId, code])
  @@index([companyId])
}

model ChartAccount {
  id                              String        @id @default(cuid())
  companyId                        String?
  company                          Company?      @relation(fields: [companyId], references: [id])
  code                            String
  description                     String
  active                          Boolean       @default(true)
  isSuper                         Boolean       @default(false)
  planType                         ChartPlanType
  parentId                         String?
  parent                           ChartAccount? @relation("ChartAccountHierarchy", fields: [parentId], references: [id])
  children                         ChartAccount[] @relation("ChartAccountHierarchy")
  revenueExpense                  RevenueExpense
  debitCredit                     DebitCredit
  fixedVariable                   FixedVariable
  costExpense                     CostExpense
  accountingCode                  String?
  dreHide                         Boolean       @default(false)
  dreGroupOtherFinIncome          Boolean       @default(false)
  dreGroupDeductionsTaxes         Boolean       @default(false)
  dreGroupInvestments             Boolean       @default(false)
  dreGroupSalesMarketing          Boolean       @default(false)
  dreGroupProfitSharing           Boolean       @default(false)
  cashflowHide                    Boolean       @default(false)
  createdAt                       DateTime      @default(now())

  allocations ChartAccountAllocation[]
  ledgerSplits BankLedgerEntrySplit[]

  @@index([companyId])
  @@index([parentId])
}

model ChartAccountAllocation {
  id             String   @id @default(cuid())
  chartAccountId  String
  chartAccount    ChartAccount @relation(fields: [chartAccountId], references: [id])
  year           Int
  annualTotal     Float   @default(0)
  createdAt      DateTime @default(now())

  lines ChartAccountAllocationLine[]

  @@unique([chartAccountId, year])
}

model ChartAccountAllocationLine {
  id            String   @id @default(cuid())
  allocationId  String
  allocation    ChartAccountAllocation @relation(fields: [allocationId], references: [id])
  month         Int
  amount        Float    @default(0)

  @@unique([allocationId, month])
}

model BankLedgerEntry {
  id            String         @id @default(cuid())
  companyId      String
  company        Company        @relation(fields: [companyId], references: [id])
  code          Int
  issueDate     DateTime
  paymentDate   DateTime?
  accountId     String?
  account       Account?       @relation(fields: [accountId], references: [id])
  documentType  String?
  documentNumber String?
  checkNumber   String?
  entityCode    String?
  amount        Float
  operation     LedgerOperation
  history       String?
  confirmed     Boolean        @default(false)
  printOnClose  Boolean        @default(false)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  deletedAt     DateTime?
  updatedById   String?
  updatedBy     User?          @relation("LedgerUpdatedBy", fields: [updatedById], references: [id])

  splits        BankLedgerEntrySplit[]
  attachments   Attachment[]

  @@index([companyId, issueDate])
  @@index([accountId])
}

model BankLedgerEntrySplit {
  id            String       @id @default(cuid())
  entryId       String
  entry         BankLedgerEntry @relation(fields: [entryId], references: [id])
  chartAccountId String
  chartAccount  ChartAccount @relation(fields: [chartAccountId], references: [id])
  costCenterId  String?
  costCenter    CostCenter?  @relation(fields: [costCenterId], references: [id])
  splitAmount   Float
  createdAt     DateTime     @default(now())

  @@index([entryId])
  @@index([chartAccountId])
}

model Attachment {
  id          String   @id @default(cuid())
  entryId     String
  entry       BankLedgerEntry @relation(fields: [entryId], references: [id])
  fileName    String
  url         String
  mime        String?
  size        Int?
  createdAt   DateTime @default(now())
}

model AuditLog {
  id        String      @id @default(cuid())
  companyId  String
  company    Company     @relation(fields: [companyId], references: [id])
  userId     String?
  user       User?       @relation(fields: [userId], references: [id])
  entity     String
  entityId   String
  action     AuditAction
  oldJson    String?
  newJson    String?
  createdAt  DateTime    @default(now())

  @@index([companyId, entity])
}

model Pendency {
  id            String          @id @default(cuid())
  companyId      String
  company        Company         @relation(fields: [companyId], references: [id])
  transactionId  String
  transaction    Transaction     @relation(fields: [transactionId], references: [id])
  type           PendencyType
  question       String
  priority       PendencyPriority
  status         PendencyStatus
  assignedTo     String
  createdAt      DateTime        @default(now())
  dueAt          DateTime
  resolvedAt     DateTime?
  resolvedBy     String?
  response       String?

  @@index([companyId, status])
  @@index([transactionId])
}

model ImportJob {
  id         String       @id @default(cuid())
  companyId  String
  company    Company      @relation(fields: [companyId], references: [id])
  source     ImportSource
  status     ImportStatus @default(QUEUED)
  filename   String?
  mimeType   String?
  path       String?
  resultJson String?
  error      String?
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  @@index([companyId, status])
}
